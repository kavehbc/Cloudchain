pragma solidity >=0.4.22 <0.7.0;
contract Math {

	// Generate a random number between 0 and 100
	function random() public view returns (uint8) {
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % 100);
    }
    
    function log(uint8 x) public view returns(uint8) {
		uint8 LOG = log2(x) / log2(10);
		return(LOG);
	}

	function log2(uint8 x) pure public returns (uint8 y){
		assembly {
        let arg := x
			x := sub(x,1)
			x := or(x, div(x, 0x02))
			x := or(x, div(x, 0x04))
			x := or(x, div(x, 0x10))
			x := or(x, div(x, 0x100))
			x := or(x, div(x, 0x10000))
			x := or(x, div(x, 0x100000000))
			x := or(x, div(x, 0x10000000000000000))
			x := or(x, div(x, 0x100000000000000000000000000000000))
			x := add(x, 1)
			let m := mload(0x40)
			mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)
			mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)
			mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)
			mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)
			mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)
			mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)
			mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)
			mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)
			mstore(0x40, add(m, 0x100))
			let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff
			let shift := 0x100000000000000000000000000000000000000000000000000000000000000
			let a := div(mul(x, magic), shift)
			y := div(mload(add(m,sub(255,a))), shift)
			y := add(y, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))
		}  
	}
	
	
	// Sin - Cos functions
	// Table index into the trigonometric table
    uint constant INDEX_WIDTH = 4;
    // Interpolation between successive entries in the tables
    uint constant INTERP_WIDTH = 8;
    uint constant INDEX_OFFSET = 12 - INDEX_WIDTH;
    uint constant INTERP_OFFSET = INDEX_OFFSET - INTERP_WIDTH;
    uint16 constant ANGLES_IN_CYCLE = 16384;
    uint16 constant QUADRANT_HIGH_MASK = 8192;
    uint16 constant QUADRANT_LOW_MASK = 4096;
    uint constant SINE_TABLE_SIZE = 16;

    // constant sine lookup table generated by gen_tables.py
    // We have no other choice but this since constant arrays don't yet exist
    uint8 constant entry_bytes = 2;
    bytes constant sin_table = "\x00\x00\x0c\x8c\x18\xf9\x25\x28\x30\xfb\x3c\x56\x47\x1c\x51\x33\x5a\x82\x62\xf1\x6a\x6d\x70\xe2\x76\x41\x7a\x7c\x7d\x89\x7f\x61\x7f\xff";

    /**
     * Convenience function to apply a mask on an integer to extract a certain
     * number of bits. Using exponents since solidity still does not support
     * shifting.
     *
     * @param _value The integer whose bits we want to get
     * @param _width The width of the bits (in bits) we want to extract
     * @param _offset The offset of the bits (in bits) we want to extract
     * @return An integer containing _width bits of _value starting at the
     *         _offset bit
     */
    function bits(uint _value, uint _width, uint _offset) pure internal returns (uint) {
        return (_value / (2 ** _offset)) & (((2 ** _width)) - 1);
    }

    function sin_table_lookup(uint index) pure internal returns (uint16) {
        bytes memory table = sin_table;
        uint offset = (index + 1) * entry_bytes;
        uint16 trigint_value;
        assembly {
            trigint_value := mload(add(table, offset))
        }

        return trigint_value;
    }

    /**
     * Return the sine of an integer approximated angle as a signed 16-bit
     * integer.
     *
     * @param _angle A 14-bit angle. This divides the circle into 16384
     *               angle units, instead of the standard 360 degrees.
     * @return The sine result as a number in the range -32767 to 32767.
     */
    function sin(int8 _angle) public pure returns (int8) {
        uint interp = bits(uint256(_angle), INTERP_WIDTH, INTERP_OFFSET);
        uint index = bits(uint256(_angle), INDEX_WIDTH, INDEX_OFFSET);

        bool is_odd_quadrant = (uint(_angle) & QUADRANT_LOW_MASK) == 0;
        bool is_negative_quadrant = (uint(_angle) & QUADRANT_HIGH_MASK) != 0;

        if (!is_odd_quadrant) {
            index = SINE_TABLE_SIZE - 1 - index;
        }

        uint x1 = sin_table_lookup(index);
        uint x2 = sin_table_lookup(index + 1);
        uint approximation = ((x2 - x1) * interp) / (2 ** INTERP_WIDTH);

        int sine;
        if (is_odd_quadrant) {
            sine = int(x1) + int(approximation);
        } else {
            sine = int(x2) - int(approximation);
        }

        if (is_negative_quadrant) {
            sine *= -1;
        }

        return int8(sine);
    }

    /**
     * Return the cos of an integer approximated angle.
     * It functions just like the sin() method but uses the trigonometric
     * identity sin(x + pi/2) = cos(x) to quickly calculate the cos.
     */
    function cos(int8 _angle) public pure returns (int8) {
        if (uint256(_angle) > ANGLES_IN_CYCLE - QUADRANT_LOW_MASK) {
            _angle = int8(QUADRANT_LOW_MASK - ANGLES_IN_CYCLE) - int8(_angle);
        } else {
            _angle += int8(QUADRANT_LOW_MASK);
        }
        return sin(_angle);
    }
    
    
    
    // SQRT
	function sqrt(int8 x) public returns (int8) {
		int8 z = (x + 1) / 2;
		int8 y = x;
		while (z < y) {
			y = z;
			z = (x / z + z) / 2;
		}
		return(y);
	}

	
	// BETA Distribution
	uint MAX_DOTS = 40;

	function gamma_lanczos(int8 z) public returns(int8){
		// Gamma function with the Lanczos approximation (found on Wikipedia)
		// https://en.wikipedia.org/wiki/Lanczos_approximation
		int8 g = 7;
		int8 pi = 3; //3.14
		int8 x;
		int8 t;
		int8[9] memory lanczos_coef = [int8(1), int8(676), int8(-1259), int8(771), int8(-176), int8(12), int8(0), int8(10), int8(0)];

		if (z < 1){
			return(pi / (sin(pi * z) * gamma(1 - z)));
		}else{
			z -= 1;
			
			int8 sum_value = 0;
			for (int8 i = 1; i < g + 1; i++) {
			    sum_value = sum_value + (lanczos_coef[uint8(i)]/(z+i));
			}
			x = lanczos_coef[0] + sum_value;
			t = z + g + 1;
			return (sqrt(2*pi) * int8(uint256(t)**uint256(z+1)) * int8(3**uint256(-t)) * x); //exp(-t) = (3**-t)
		}
	}
	
	
	function gamma(int8 x) public returns (int8){
        int8 z = gamma_lanczos(x);
        return z;
	}
	
	function min(int8 a, int8 b) public returns (int8){
	    if (a < b){
	        return(a);
	    }else{
	        return(b);
	    }
	}
	
	function INTEGRAL(uint8 f, int8 lo, int8 hi, int8 epsilon, int8 alpha, int8 beta, int8 a, int8 b) public returns (int8){
        int8 summe = 0;
        int8[] memory A;
        int8[] memory tr;

        (A, tr) = iterIntegral(f, lo, hi, epsilon, alpha, beta, a, b);
        for (uint8 i = 0; i < A.length; i++) {
            summe += A[i];
        }
        return(summe);
	}
	
	struct funcVars {
            int8 t;
            int8 tr;
            int8 y;
            int8 yr;
            int8 m;
            int8 A;
        }
        
	function iterIntegral(uint8 f, int8 lo, int8 hi, int8 epsilon, int8 alpha, int8 beta, int8 a, int8 b) public returns (int8[] memory, int8[] memory){
        
        funcVars memory vars;
        
        //f = 1; beta_pdf_nominator
        //f = 2; beta_pdf
        
        int8[] memory result1;
        int8[] memory result2;
        uint256 counter = 0;
        
        if (lo < hi){
            vars.t = lo;
            while (vars.t <= hi){
                vars.tr = min(hi, vars.t + epsilon);
                if (f == 1){
                    vars.y = beta_pdf_nominator(vars.t, alpha, beta, a, b, 10);
                    vars.yr = beta_pdf_nominator(vars.tr, alpha, beta, a, b, 10);
                }else if(f == 2){
                    vars.y = beta_pdf(vars.t, alpha, beta, a, b, 10);
                    vars.yr = beta_pdf(vars.t, alpha, beta, a, b, 10);
                }
                vars.m = (vars.y + vars.yr) / 2;
                vars.A = vars.m * (vars.tr - vars.t);
                result1[counter] = vars.A;
                result2[counter] = vars.tr;
                if (vars.tr >= hi){
                    break;
                }
                vars.t = vars.tr;
                continue;
                
               counter++;
            }
        }
        return (result1, result2);
	}
	
	
	function BETA_GAMMA(int8 alpha, int8 beta, int8 a, int8 b) public returns(int8){
        int8 gamma_quot = (gamma(alpha)*gamma(beta)/gamma(alpha+beta));
        return gamma_quot;
	}
    
    function BETA_INTEGRAL(int8 alpha, int8 beta, int8 a, int8 b, int8 epsilon) public returns(int8){
        // bytes4 f = lambda t : beta_pdf_nominator(t, alpha, beta, a, b);
        return INTEGRAL(1, a, b, epsilon, alpha, beta, a, b);
    }

    function BETA(int8 alpha, int8 beta, int8 a, int8 b) public returns(int8){
        return BETA_GAMMA(alpha, beta, a, b);
    }
    
    // beta_cache = {}
    // function BETA_CACHED(int8 alpha, int8 beta, int8 a, int8 b)public returns(int8){
    //     key = (alpha, beta, a, b)
    //     if not key in beta_cache:
    //         B = BETA(alpha, beta, a, b)
    //         beta_cache[key] = B
    //     return beta_cache[key]
    // }
    
    function beta_pdf_nominator(int8 x, int8 alpha, int8 beta, int8 a, int8 b, int8 infinite) public returns (int8){
        // infinite = 10.0;
        int8 NULL = 0;
        if ((x < a) || (x > b)){
            return(NULL);
        }
        if ((alpha > 0) && (beta > 0)){
            int8 num = int8(uint8(x-a) ** uint8(alpha-1) * uint8(b-x) ** uint8(beta-1) * 1000);
            return(num);
        }
        return(NULL);
    }

    function beta_pdf(int8 x, int8 alpha, int8 beta, int8 a, int8 b, int8 infinite) public returns (int8){
        int8 NULL = 0;
        if ((x < a) || (x > b)){
            return(NULL);
        }
        if ((alpha > 0) && (beta > 0)){
            int8 num = beta_pdf_nominator(x, alpha, beta, a, b, infinite = infinite);
            int8 den = int8(uint8(BETA(alpha,beta,a,b)) * uint8(b-a) ** uint8(alpha+beta-1));
            return(num/den);
        }
        return(NULL);
    }

    function beta_cdf(int8 x, int8 alpha, int8 beta, int8 a, int8 b, int8 epsilon) public returns (int8) {
   
        // if (x < a) || (x > b){
        //     raise ValueError("x outside support [a,b]")
        // }
        if ((alpha > 0) && (beta > 0)){
            // f = lambda t : beta_pdf(t, alpha, beta, a, b);
            return(INTEGRAL(2, a, x, epsilon, alpha, beta, a, b));
        }
        // raise ValueError("precondition violated: alpha, beta > 0")
    }

    function beta_inv(int8 conf, int8 alpha, int8 beta, int8 a, int8 b, int8 epsilon) public returns (int8){
        // if ((conf < 0) || (conf > 1)){
        //     raise ValueError("conf outside support [0,1]");
        // }
        // if ((alpha <= 0) || (beta <= 0)){
        //     raise ValueError("precondition violated: alpha, beta > 0");
        // }
        int8 summe = 0;
        // f = lambda t : beta_pdf(t, alpha, beta, a, b);
        
        int8[] memory A;
        int8[] memory tr;
        (A, tr) = iterIntegral(2, a, b, epsilon, alpha, beta, a, b);
        
        for (uint256 i = 0; i < A.length; i++){
            summe = summe + A[i];
            if (summe >= conf){
                return tr[i];
            }
        }
        return(summe);
    }

    function alphaBetaFromAmB(int8 a, int8 m, int8 b) public returns(int8, int8){
        int8 first_numer_alpha = 2 * (b + 4 * m - 5 * a);
        int8 first_numer_beta = 2 * (5 * b - 4 * m - a);
        int8 first_denom = 3 * (b - a);
        int8 second_numer = (m - a) * (b - m);
        int8 second_denom = int8(uint8(b - a) ** 2);
        int8 second = (1 + 4 * (second_numer / second_denom));
        int8 alpha = (first_numer_alpha / first_denom) * second;
        int8 beta = (first_numer_beta / first_denom) * second;
        return(alpha, beta);
    }
        
    
}
